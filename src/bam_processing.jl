"""
    get_bedtools_depth!(bamFile,bins,binFile,chromFile;newCol=:depth,bedtools="bedtools")

Calculates read depth in a bam file across a given set of bins using bedtools coverage.
# Arguments
*  bamFile::String Path to input bam/cram/bed file of WGS data
*  bins::DataFrame DataFrame of bins generated by fixbin/flexbin_generation.jl scripts
*  binFile::String Path to bedfile of the bin coordinates
*  chromFile::String Path to tsv of chromosome name and size in order.
*  newCol::Symbol Name of new column to add to dataframe (default :depth)
*  bedtools::String Path to bedtools executable (default bedtools)
"""
function get_bedtools_depth!(bamFile::String,bins::DataFrame,
	binFile::String,chromFile::String;newCol::Symbol=:depth,
	bedtools::String="bedtools")

	data = read(`$bedtools coverage -sorted -g $chromFile -counts -a $binFile -b $bamFile`,String)
	countD = CSV.File(IOBuffer(data),delim='\t',header=false) |> DataFrame
	@assert size(countD,1) == size(bins,1)
	bins[!,newCol] .= [Float64(x) for x in countD[!,:Column4]]
end


"""
    write_bedtools_tempfiles(bins,outDir)

Generates temp files required to run bedtools coverage
# Arguments
*  bins::DataFrame DataFrame of bins generated by fixbin/flexbin_generation.jl scripts
*  outDir::String Path to directory to place temp files
"""
function write_bedtools_tempfiles(bins::DataFrame,outDir::String)
	out = open(joinpath(outDir,"binCoords.bed"),"w")
	for r in eachrow(bins)
		write(out,"$(r[:chrom])\t$(r[:startPos]-1)\t$(r[:endPos])\n")
	end
	close(out)

	out = open(joinpath(outDir,"chromOrder.tsv"),"w")
	for c in unique(bins.chrom)
		df = bins |> @filter(_.chrom == c)  |> DataFrame
		write(out,"$c\t$(maximum(df.endPos))\n")
	end
	close(out)
end

"""
    normalize_depth!(readData,method;depthCol=:depth,ctrlData=nothing,loessSpan=0.05,normCol=:NA)

Normalizes the depth values in depthCol using a particular method:  

mean: r[depthCol] -> r[depthCol] / mean(readData.depthCol)\n
median: r[depthCol] -> r[depthCol] / median(readData.depthCol)\n
log: r[depthCol] -> log(r[depthCol])\n
invlog: r[depthCol] -> exp(r[depthCol])\n

zscore: readData[!,depthCol] -> zscore(readData[!,depthCol])\n
gc: readData[!,depthCol] -> readData[!,depthCol] - Loess.predict(model,readData[!,:gc])\n
mappability: readData[!,depthCol] -> readData[!,depthCol] - Loess.predict(model,readData[!,:map])\n

Requires ctrlData:\n
ctrls: readData[!,depthCol] -> readData[!,depthCol] - ctrlData[!,depthCol]  

Requires normCol:\n
col: r[depthCol] -> r[depthCol] - r[normCol]  

# Arguments
*  readData::DataFrame DataFrame with data in a column name matching depthCol
*  method::String Normalization method selected from above.
*  depthCol::Symbol Name of column containing depth data (default :depth)
*  ctrlData::DataFrame Matching df of bins w/ ctrl sample data for "ctrls" method (default nothing)
*  loessSpan::Float64 Span parameter for loess smoothing (default 0.05)
*  normCol::Symbol Name of column for "normCol" method (default :NA)

"""
function normalize_depth!(readData::DataFrame,method::String;ctrlData=nothing,
	loessSpan::Float64=0.05,depthCol::Symbol=:depth,normCol::Symbol=:NA)

	if method == "mean"
		meanDepth = mean(readData[!,depthCol])
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] / meanDepth
		end

	elseif method == "median"
		avgDepth = median(readData[!,depthCol])
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] / avgDepth
		end

	elseif method == "zscore"
		scores = zscore(readData[!,depthCol])
		readData[!,depthCol] .= scores

	elseif method == "ctrls"
		@assert typeof(ctrlData) == DataFrame
		@assert size(readData,1) == size(ctrlData,1)
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] - ctrlData[idx,depthCol]
		end

	elseif method == "col"
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] - readData[idx,normCol]
		end

	elseif method == "log"
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = log(readData[idx,depthCol])
		end

	elseif method == "invlog"
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = exp(readData[idx,depthCol])
		end
	
	elseif method == "gc"
		model = loess(readData[!,:gc],readData[!,depthCol],span=loessSpan)
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] - Loess.predict(model,readData[idx,:gc])
		end

	elseif method == "mappability"
		model = loess(readData[!,:map],readData[!,depthCol],span=loessSpan)
		for idx in range(1,stop=size(readData,1))
			readData[idx,depthCol] = readData[idx,depthCol] - Loess.predict(model,readData[idx,:map])
		end
	end
end
