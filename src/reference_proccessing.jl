
mutable struct Window
	chrom::String
	rNum::Int
	rStart::Int
	rEnd::Int
	chromLen::Int
	data::Dict{String,Float64}
end


"""
    get_fixedbin_coords(chromSizeFile,binSize)

Generates a DataFrame of bins of a fixed size across all choromosomes.
# Arguments
*  chromSizeFile::String Tab-delimited file of chromName and chromSize in bp
*  binSize::Int Bin size in bp
"""
function get_fixedbin_coords(chromSizeFile::String,binSize::Integer)
	chromSizes = CSV.File(chromSizeFile,delim='\t',header=false) |> DataFrame
	W = Vector{Vector{Window}}()

	for r in eachrow(chromSizes)
		c = string(r[:Column1])
		l = r[:Column2]
		push!(W,get_fixed_windows(c,binSize,l))
	end

	chrom = String[]
	startPos = Int[]
	endPos = Int[]
	for c in W
		for b in c
			push!(chrom,b.chrom)
			push!(startPos,b.rStart)
			push!(endPos,b.rEnd)
		end
	end
	return DataFrame(chrom=chrom,startPos=startPos,endPos=endPos)
end


"""
    get_flexbin_coords(numBins,minMap,gemWig;maxSize,goodChrom)

Generates a DataFrame of bins of variable sized bins, with each bin containing
approximately the same number of mappable bases.
# Arguments
*  numBins::Int Number of bins across the genome
*  minMap::Float64 Minimum mappability value for a base to count
*  gemWig::String Path to wig file of mappability from GemMap
*  maxSize::Real Maximum bin size in bp (default Inf)
*  goodChrom::Vector{String} Vector of chrom names from gemWig to make bins for. (default all chroms)
"""
function get_flexbin_coords(numBins::Integer,minMap::Float64,
	gemWig::String;maxSize::Real=typemax(Int64),outName::String="",
	goodChrom::Vector{String}=String[])

	if maxSize > typemax(Int32)
		iType = Int64
	else
		iType = Int32
	end

	C = Dict{String,Bool}()
	if length(goodChrom) > 0
		for i in goodChrom
			C[i] = true
		end
	end

	if occursin(".gz",gemWig) == true
		wig = GZip.open(gemWig,"r")
	else
		wig = open(gemWig,"r")
	end

	M = Dict{String,Vector{UnitRange{iType}}}()
	chr = ""
	span = 0
	for ln in eachline(wig)
		if occursin("chrom=",ln) == true
			d = [split(x,'=') for x in split(ln,' ')]
			chr,span = [string(d[2][2]),parse(iType,d[3][2])]

			#If a list of chroms is provided, skip the chrom if its not on the list.
			#If a list isnt provided, add to the chrom list in correct order.
			if length(C) > 0 && haskey(C,chr) == false 
				continue
			elseif length(C) == 0
				push!(goodChrom,chr)
			end

			if haskey(M,chr) == false
				M[chr] = UnitRange{iType}[]
			end
		else
			d = split(ln,' ')
			if parse(Float64,d[2]) >= minMap && haskey(M,chr) == true
				push!(M[chr],range(parse(iType,d[1]),length=span))
			end
		end
	end
	close(wig)
	
	totalGoodBase = 0
	for c in keys(M)
		totalGoodBase += sum([length(r) for r in M[c]])
	end
	basesPerBin = round(totalGoodBase/numBins,digits=0)

	chrom = String[]
	startPos = Int[]
	endPos = Int[]
	for c in goodChrom
		bCount = 0
		s::iType = 1
		e::iType = 0
		for r in M[c]
			bCount += length(r)
			e = r[end]
			if bCount > basesPerBin
				push!(chrom,c)
				push!(startPos,s)
				push!(endPos,e)
				s = e+1
				e = 0
				bCount = 0
			end
		end
	end
	return DataFrame(chrom=chrom,startPos=startPos,endPos=endPos)
end

"""
    annotate_bin_composition!(inFasta,bins)

Adds gc and bases columns to bin DataFrame with gc proportion and number of bases in the bin.
# Arguments
*  inFasta::String Path to reference genome
*  bins::DataFrame DataFrame of bins with columns chrom, startPos, endPos
"""
function annotate_bin_composition!(inFasta::String,bins::DataFrame)
	REF = FASTX.FASTA.Reader(open(inFasta,"r"))
	record = FASTX.FASTA.Record()

	bins[:,:gc] .= 0.0
	bins[:,:bases] .= 0

	while !eof(REF)
		read!(REF, record)
		c = FASTX.FASTA.identifier(record)
		l = length(FASTX.FASTA.sequence(record))

		for (idx,r) in enumerate(eachrow(bins))
			if r[:chrom] == c
				seq = FASTX.FASTA.sequence(record)[r[:startPos]:r[:endPos]]
				comp = composition(seq)
				nucCount = length(seq) - comp[DNA_N]
				bins[idx,:bases] = nucCount
				bins[idx,:gc] = round((comp[DNA_G] + comp[DNA_C]) / nucCount,digits=3)
			end
		end
	end
	return bins |> @filter(_.bases > 0) |> DataFrame
end

"""
    annotate_bin_mappability!(gemWig,bins)

Adds map column to bin DataFrame with average mappability of the bin calculated by GemMap.
# Arguments
*  gemWig::String Path to mappability wig file generated by GemMap.
*  bins::DataFrame DataFrame of bins with columns chrom, startPos, endPos
"""
function annotate_bin_mappability!(gemWig::String,bins::DataFrame)
	if maximum(bins[!,:endPos]) > typemax(Int32)
		iType = Int64
	else
		iType = Int32
	end

	B = Dict{Int,Window}()
	bins[!,:map] .= 0.0
	for (idx,r) in enumerate(eachrow(bins))
		B[idx] = Window(r[:chrom],idx,r[:startPos],r[:endPos],0,Dict{String,Float64}())
	end

	if occursin(".gz",gemWig) == true
		wig = GZip.open(gemWig,"r")
	else
		wig = open(gemWig,"r")
	end

	M = Dict{String,Vector{Tuple}}()
	chr = ""
	span = 0
	for ln in eachline(wig)
		if occursin("chrom=",ln) == true
			d = [split(x,'=') for x in split(ln,' ')]
			chr,span = [string(d[2][2]),parse(iType,d[3][2])]
			if haskey(M,chr) == false
				M[chr] = Tuple[]
			end
		else
			d = split(ln,' ')
			#Tuple of (coordRange,mapValue)
			push!(M[chr],Tuple{UnitRange{Int},Float16}([range(parse(iType,d[1]),length=span),parse(Float16,d[2])]))
		end
	end
	close(wig)

	for idx in keys(B)
		bSize = B[idx].rEnd - B[idx].rStart
		binCoords = [B[idx].rStart,B[idx].rEnd]
		mapVals = 0.0
		mapCount = 0
		for r in M[B[idx].chrom]
			if r[1][end] < binCoords[1]
				continue
			elseif r[1][1] > binCoords[2]
				break
			end
			coords = [r[1][1],r[1][end]]
			ov = getoverlap(coords,binCoords)
			if ov > 0
				mapCount += ov
				mapVals += ov * r[2]
			end
		end
		bins[idx,:map] = mapVals / mapCount
	end
	return bins
end
